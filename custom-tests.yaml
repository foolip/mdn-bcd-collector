#
# mdn-bcd-collector: custom-tests.yaml
# Custom test code to override auto-generated test code
#
# Â© Gooborg Studios, Mozilla Corporation, Google LLC, Apple Inc
# See the LICENSE file for copyright details
#

# Custom tests here also need to be in @webref/idl or custom-idl/, see
# https://github.com/foolip/mdn-bcd-collector/issues/1944.
api:
  __resources:
    audio-blip:
      type: audio
      src:
        - /media/blip.mp3
        - /media/blip.ogg
    video-blank:
      type: video
      src:
        - /media/blank.mp4
        - /media/blank.webm
      subtitles:
        - label: English
          lang: en
          src: /media/subtitles.vtt
    image-black:
      type: image
      src: /media/black.png
    audioContext:
      type: instance
      src: |-
        var constructor = window.AudioContext || window.webkitAudioContext;
        if (!constructor) {
          return null;
        }
        return new constructor();
    createStyleSheet:
      type: instance
      src: |-
        return function(css) {
          var el = document.createElement('style');
          el.innerHTML = css;
          document.head.appendChild(el);
          el.sheet.disabled = true;
          return el.sheet;
        }
    cryptoKey:
      type: instance
      src: |-
        if (!('crypto' in self) || !crypto) {
          return null;
        };
        var subtle = crypto.subtle || crypto.webkitSubtle;
        if (!subtle) {
          return null;
        };
        return subtle.generateKey({
          name: 'RSA-OAEP',
          modulusLength: 4096,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: 'SHA-256'
        }, true, ['encrypt', 'decrypt']).then(function(pair) {
          return pair.publicKey;
        });
    offlineAudioContext:
      type: instance
      src: |-
        var constructor = window.OfflineAudioContext || window.webkitOfflineAudioContext;
        if (!constructor) {
          return null;
        }
        return new constructor(2,44100*40,44100);
    speechRecognition:
      type: instance
      src: |-
        var constructor = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!constructor) {
          return null;
        }
        return new constructor();
    webGL:
      type: instance
      src: |-
        var canvas = document.createElement('canvas');
        if (!canvas) {
          return null;
        };
        return canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    webGL1:
      type: instance
      src: |-
        var canvas = document.createElement('canvas');
        if (!canvas) {
          return null;
        };
        return canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    webGL2:
      type: instance
      src: |-
        var canvas = document.createElement('canvas');
        if (!canvas) {
          return null;
        };
        return canvas.getContext('webgl2');

  _globals:
    crypto: return !!self.crypto;
  Attr:
    __base: |-
      var el = document.createElement('b');
      el.setAttribute('data-foo', 'bar');
      var instance;
      if ('getAttributeNode' in el) {
        instance = el.getAttributeNode('data-foo');
      } else if ('attributes' in el) {
        instance = el.attributes.item(0);
      }
  ANGLE_instanced_arrays:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('ANGLE_instanced_arrays');
    __test: return !!instance;
  AnalyserNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createAnalyser();
  AnimationEvent:
    __base: |-
      var instance;
      try {
        instance = new AnimationEvent('animationend');
      } catch(e) {
        try {
          instance = document.createEvent('AnimationEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  ApplicationCache:
    __base: var instance = window.applicationCache;
  AudioBuffer:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createBuffer(2, reusableInstances.audioContext.sampleRate * 3, reusableInstances.audioContext.sampleRate);
  AudioBufferSourceNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createBufferSource();
  AudioContext:
    __resources:
      - audioContext
    __base: var instance = reusableInstances.audioContext;
    __test: return 'AudioContext' in self;
  AudioDestinationNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.destination;
  AudioListener:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.listener;
  AudioNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createAnalyser();
  AudioParam:
    __resources:
      - audioContext
    __base: <%api.GainNode:gainNode%> var instance = gainNode.gain;
  AudioProcessingEvent:
    __base: |-
      var instance;
      try {
        instance = new AudioProcessingEvent('audioprocess');
      } catch(e) {
        try {
          instance = document.createEvent('AudioProcessingEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  AudioScheduledSourceNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createBufferSource();
    __test: return 'AudioScheduledSourceNode' in self;
  AudioTrack:
    __resources:
      - audio-blip
    __base: <%api.AudioTrackList:audioTracks%> var instance = audioTracks[0];
  AudioTrackList:
    __resources:
      - audio-blip
    __base: |-
      var el = document.getElementById('resource-audio-blip');
      var instance = el.audioTracks;
  AudioWorkletNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if
      (!reusableInstances.audioContext.audioWorklet) {
        return {result: false, message: 'Audio worklets are not available'};
      }
      var promise = reusableInstances.audioContext.audioWorklet.addModule('/resources/custom-tests/api/AudioWorkletNode/WhiteNoiseProcessor.js').then(
        function() {
          return new AudioWorkletNode(reusableInstances.audioContext, 'white-noise-processor')
        }
      );
      promise.then(function() {});
  BarProp:
    __base: var instance = window.toolbar;
  BaseAudioContext:
    __resources:
      - audioContext
    __base: var instance = reusableInstances.audioContext;
    __test: return 'BaseAudioContext' in self;
    __additional:
      decodeAudioData.returns_promise: |-
        <%api.BaseAudioContext:ctx%>
        return ctx.decodeAudioData.length === 1;
  # XXX Freezes in many versions of Chrome and Firefox
  # BatteryManager:
  #   __base: |-
  #     if (!('getBattery' in navigator)) {
  #       return {result: false, message: 'navigator.getBattery() is not defined'};
  #     };
  #     var promise = navigator.getBattery();
  #     promise.then(function() {});
  BeforeInstallPromptEvent:
    __base: |-
      try {
        var instance = new BeforeInstallPromptEvent('');
      } catch(e) {
        if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
          return {result: false, message: 'Cannot create event'};
        }
        throw e;
      }
  BeforeUnloadEvent:
    __base: |-
      try {
        var instance = document.createEvent('BeforeUnloadEvent');
      } catch(e) {
        if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
          return {result: false, message: 'Cannot create event'};
        }
        throw e;
      }
  BiquadFilterNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createBiquadFilter();
  ByteLengthQueuingStrategy:
    __base: |-
      if (!('ByteLengthQueuingStrategy' in self)) {
        return {result: false, message: 'ByteLengthQueuingStrategy is not defined'};
      }
      var instance = new ByteLengthQueuingStrategy({ highWaterMark: 1 });
  Blob:
    __base: |-
      var instance;
      try {
        instance = new Blob();
      } catch(e) {
        instance = new BlobBuilder();
      }
  CacheStorage:
    __base: |-
      if (!('caches' in self)) {
        return {result: false, message: 'caches is not defined'};
      };
      var instance = caches;
  CanvasGradient:
    __base: |-
      <%api.CanvasRenderingContext2D:ctx%>
      var instance;
      if (ctx.createLinearGradient) {
        instance = ctx.createLinearGradient(0, 0, 1, 1);
      } else if (ctx.createRadialGradient) {
        instance = ctx.createRadialGradient(0, 0, 0, 1, 1, 1);
      } else {
        return {result: false, message: 'Could not create linear or radial gradient'};
      }
  CanvasPattern:
    __resources:
      - image-black
    __base: |-
      <%api.CanvasRenderingContext2D:ctx%>
      var instance = ctx.createPattern(document.getElementById('resource-image-black'), 'repeat');
  CanvasRenderingContext2D:
    __base: |-
      if (!('document' in self)) {
        // XXX Implement worker tests for CanvasRenderingContext2D
        return {result: null, message: 'Testing CanvasRenderingContext2D in workers is not yet implemented'};
      }
      var canvas = document.createElement('canvas');
      if (!canvas) {
        return {result: false, message: 'Could not create canvas element'};
      };
      var instance = canvas.getContext('2d');
    __additional:
      drawFocusIfNeeded.path_parameter: |-
        var path = new Path2D();
        var el = document.createElement('p');
        try {
          instance.drawFocusIfNeeded(path, el);
          return true;
        } catch(e) {
          return {result: false, message: e.message};
        }
      drawImage.SVGImageElement_source_image: |-
        <%api.SVGImageElement:image%>
        try {
          instance.drawImage(image, 0, 0);
        } catch (e) {
          if (e.name === 'TypeError') {
            // Safari throws a TypeError for lack of support
            return {result: false, message: 'TypeError'};
          }
        }
        return true;
      setTransform.matrix_parameter: |-
        var matrix = new DOMMatrix([1, .2, .8, 1, 0, 0]);
        try {
          instance.setTransform(matrix);
          return true;
        } catch(e) {
          return {result: false, message: e.message};
        }
  ChannelMergerNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createChannelMerger();
  ChannelSplitterNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createChannelSplitter();
  CharacterData:
    __base: <%api.Text:instance%>
  Clients:
    __base: var instance = clients;
  CloseEvent:
    __base: |-
      var instance;
      try {
        instance = new CloseEvent('close');
      } catch(e) {
        try {
          instance = document.createEvent('CloseEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  CompositionEvent:
    __base: |-
      var instance;
      try {
        instance = new CompositionEvent('compositionstart');
      } catch(e) {
        try {
          instance = document.createEvent('CompositionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  ConstantSourceNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createConstantSource();
  ConvolverNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createConvolver();
  CountQueuingStrategy:
    __base: |-
      if (!('CountQueuingStrategy' in self)) {
        return {result: false, message: 'CountQueuingStrategy is not defined'};
      }
      var instance = new CountQueuingStrategy({ highWaterMark: 1 });
  Crypto:
    __base: |-
      if (!('crypto' in self)) {
        return {result: false, message: 'crypto is not defined'};
      };
      var instance = crypto;
  CryptoKey:
    __resources:
      - cryptoKey
    __base: |-
      var promise = reusableInstances.cryptoKey;
  CSSConditionRule:
    __resources:
      - createStyleSheet
    __base: <%api.CSSMediaRule:instance%>
  CSSCounterStyleRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@counter-style thumbs {system: cyclic; symbols: "ð"; suffix: " ";}');
      var instance = stylesheet.cssRules.item(0);
  CSSFontFaceRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@font-face {font-family: somefont; src: url(somefont.ttf);}');
      var instance = stylesheet.cssRules.item(0);
  CSSFontFeatureValuesRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@font-feature-values Font {@styleset {nice-style: 12;}}');
      var instance = stylesheet.cssRules.item(0);
  CSSGroupingRule:
    __resources:
      - createStyleSheet
    __base: <%api.CSSMediaRule:instance%>
  CSSImportRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@import url(/resources/style.css);');
      var instance = stylesheet.cssRules.item(0);
  CSSKeyframeRule:
    __resources:
      - createStyleSheet
    __base: |-
      <%api.CSSKeyframesRule:keyframes%>
      var instance = keyframes.cssRules.item(0);
  CSSKeyframesRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@keyframes test {0% {top: 0 } 100% { top: 100px; }} @-webkit-keyframes test {0% { top: 0 } 100% { top: 100px; }} @-moz-keyframes test {0% { top: 0 } 100% { top: 100px; }} @-o-keyframes test {0% { top: 0 } 100% { top: 100px; }}');
      var instance = stylesheet.cssRules.item(0);
  CSSMediaRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@media (max-width: 600px) {body {background-color: #111;color: white;}}');
      var instance = stylesheet.cssRules.item(0);
  CSSNamespaceRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@namespace svg url(http://www.w3.org/2000/svg);');
      var instance = stylesheet.cssRules.item(0);
  CSSPageRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@page {margin: 1cm;}');
      var instance = stylesheet.cssRules.item(0);
  CSSRule:
    __resources:
      - createStyleSheet
    __base: |-
      <%api.CSSRuleList:cssRules%>
      var instance = cssRules.item(0);
  CSSRuleList:
    __resources:
      - createStyleSheet
    __base: |-
      <%api.CSSStyleSheet:stylesheet%>
      var instance = stylesheet.cssRules;
  CSSStyleDeclaration:
    __base: |-
      var el = document.createElement('b');
      var instance = el.style;
  CSSStyleRule:
    __resources:
      - createStyleSheet
    __base: <%api.CSSRule:instance%>
  CSSStyleSheet:
    __resources:
      - createStyleSheet
    __base: "var instance = reusableInstances.createStyleSheet('p {color: red;}');"
  CSSSupportsRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@supports (display: grid) {div {display: grid;}}');
      var instance = stylesheet.cssRules.item(0);
  CSSViewportRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@viewport {width: 100vw;}');
      var instance = stylesheet.cssRules.item(0);
  CustomEvent:
    __base: |-
      var instance;
      try {
        instance = new CustomEvent('custom');
      } catch(e) {
        try {
          instance = document.createEvent('CustomEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  DelayNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createDelay();
  DeviceMotionEvent:
    __base: |-
      var instance;
      try {
        instance = new DeviceMotionEvent('devicemotion');
      } catch(e) {
        try {
          instance = document.createEvent('DeviceMotionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  DeviceOrientationEvent:
    __base: |-
      var instance;
      try {
        instance = new DeviceOrientationEvent('deviceorientation');
      } catch(e) {
        try {
          instance = document.createEvent('DeviceOrientationEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  Document:
    __base: var instance = document;
  DocumentFragment:
    __base: |-
      if (!('createDocumentFragment' in document)) {
        return {result: false, message: 'document.createDocumentFragment is not defined'};
      }
      var instance = document.createDocumentFragment();
  DocumentType:
    __base: |-
      if (!('doctype' in document)) {
        return {result: false, message: 'document.doctype is not defined'};
      }
      var instance = document.doctype;
  DOMError:
    __base: |-
      if (!('DOMError' in self)) {
        return {result: false, message: 'DOMError is not defined'};
      }
      var instance = new DOMError('name');
  DOMException:
    __base: |-
      var instance;
      try {
        document.createElement('1');
      } catch (e) {
        instance = e;
      }
  DOMImplementation:
    __base: var instance = document.implementation;
  DOMRectList:
    __base: |-
      <%api.Element:el%>
      if (!('getClientRects' in el)) {
        return {result: false, message: 'el.getClientRects is not defined'};
      }
      var instance = el.getClientRects();
  DOMTokenList:
    __base: |-
      var elm = document.createElement('b');
      var instance = elm.classList;
    __additional:
      trim_whitespace: |-
        if (!instance) {
          return {result: false, message: 'Element.classList is not defined'};
        }
        elm.className = ' foo bar foo ';
        instance.remove('bar');
        return elm.className === 'foo foo' || elm.className === 'foo';
      remove_duplicates: |-
        if (!instance) {
          return {result: false, message: 'Element.classList is not defined'};
        }
        elm.className = ' foo bar foo ';
        instance.remove('bar');
        return elm.className === 'foo';
      toggle.force_parameter: |-
        if (!instance) {
          return {result: false, message: 'Element.classList is not defined'};
        }
        elm.className = 'foo bar';
        if (!('toggle' in instance)) {
          return {result: false, message: 'Element.classList.toggle is not defined'};
        }
        instance.toggle('foo', true);
        return elm.className === 'foo bar';
  DragEvent:
    __base: |-
      var instance;
      try {
        instance = new DragEvent('drag');
      } catch(e) {
        try {
          instance = document.createEvent('DragEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  DynamicsCompressorNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createDynamicsCompressor();
  Element:
    __base: |-
      var instance;
      try {
        instance = document.createElementNS('', 'el');
      } catch(e) {
        instance = document.createElement('b');
      }
    __additional:
      scroll.options_behavior_parameter: return bcd.testOptionParam(instance, 'scroll', 'behavior', 'auto');
      scroll.options_left_parameter: return bcd.testOptionParam(instance, 'scroll', 'left', '0');
      scroll.options_top_parameter: return bcd.testOptionParam(instance, 'scroll', 'top', '0');
      scrollBy.options_behavior_parameter: return bcd.testOptionParam(instance, 'scrollBy', 'behavior', 'auto');
      scrollBy.options_left_parameter: return bcd.testOptionParam(instance, 'scrollBy', 'left', '0');
      scrollBy.options_top_parameter: return bcd.testOptionParam(instance, 'scrollBy', 'top', '0');
      scrollTo.options_behavior_parameter: return bcd.testOptionParam(instance, 'scrollTo', 'behavior', 'auto');
      scrollTo.options_left_parameter: return bcd.testOptionParam(instance, 'scrollTo', 'left', '0');
      scrollTo.options_top_parameter: return bcd.testOptionParam(instance, 'scrollTo', 'top', '0');
  ErrorEvent:
    __base: |-
      var instance;
      try {
        instance = new ErrorEvent('error');
      } catch(e) {
        try {
          instance = document.createEvent('ErrorEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  Event:
    __base: |-
      var instance;
      try {
        instance = new Event('type');
      } catch(e) {
        try {
          instance = document.createEvent('Event');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  EventSource:
    __base: |-
      if (!('EventSource' in self)) {
        return {result: false, message: 'EventSource is not defined'};
      }
      var instance = new EventSource('/eventstream');
    EventSource: return !!instance;
  EXT_blend_minmax:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_blend_minmax');
  EXT_clip_cull_distance:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('EXT_clip_cull_distance');
  EXT_color_buffer_float:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      var instance = reusableInstances.webGL2.getExtension('EXT_color_buffer_float');
  EXT_color_buffer_half_float:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_color_buffer_half_float');
  EXT_disjoint_timer_query:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_disjoint_timer_query');
  EXT_disjoint_timer_query_webgl2:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      var instance = reusableInstances.webGL2.getExtension('EXT_disjoint_timer_query_webgl2');
  EXT_float_blend:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('EXT_float_blend');
  EXT_frag_depth:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_frag_depth');
  EXT_shader_texture_lod:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_shader_texture_lod');
  EXT_sRGB:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_sRGB');
  EXT_texture_compression_bptc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('EXT_texture_compression_bptc');
  EXT_texture_compression_rgtc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('EXT_texture_compression_rgtc');
  EXT_texture_filter_anisotropic:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('EXT_texture_filter_anisotropic');
  EXT_texture_norm16:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      var instance = reusableInstances.webGL2.getExtension('EXT_texture_norm16');
  ExtendableEvent:
    __base: |-
      if (!('ExtendableEvent' in self)) {
        return {result: false, message: 'ExtendableEvent is not defined'};
      }
      var instance = new ExtendableEvent('extendable');
  External:
    __base: var instance = window.external;
  FetchEvent:
    __base: |-
      <%api.Request:req%>
      if (!('FetchEvent' in self)) {
        return {result: false, message: 'FetchEvent is not defined'};
      }
      var instance = new FetchEvent('fetch', { request: req });
  FileReader:
    __base: var instance = new FileReader();
  FocusEvent:
    __base: |-
      var instance;
      try {
        instance = new FocusEvent('focus');
      } catch(e) {
        try {
          instance = document.createEvent('FocusEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  FontFace:
    __base: |-
      if (!('FontFace' in self)) {
        return {result: false, message: 'FontFace is not defined'};
      }
      var instance = new FontFace('Material Design Icons', 'url(/fonts/materialdesignicons-webfont.woff)', {});
  FontFaceSet:
    __base: |-
      var instance;
      if ('document' in self) {
        instance = document.fonts;
      } else {
        instance = self.fonts;
      }
  FontFaceSetLoadEvent:
    __base: |-
      if (!('FontFaceSetLoadEvent' in self)) {
        return {result: false, message: 'FontFaceSetLoadEvent is not defined'};
      }
      var instance = new FontFaceSetLoadEvent('loading');
  GainNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createGain();
  GamepadEvent:
    __base: |-
      if (!('GamepadEvent' in self)) {
        return {result: false, message: 'GamepadEvent is not defined'};
      }
      var instance = new GamepadEvent('gamepadconnected');
  HashChangeEvent:
    __base: |-
      var instance;
      try {
        instance = new HashChangeEvent('hashchange');
      } catch(e) {
        try {
          instance = document.createEvent('HashChangeEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  History:
    __base: var instance = history;
  HTMLAllCollection:
    __base: |-
      // XXX document.all seems to be falsy, at least in Chrome
      var instance = document.all;
    __test: return bcd.testObjectName(instance, 'HTMLAllCollection');
  HTMLAnchorElement:
    __base: var instance = document.createElement('a');
    __test: return bcd.testObjectName(instance, 'HTMLAnchorElement');
    toString: |-
      instance.href = 'https://mdn-bcd-collector.appspot.com/';
      return instance.toString() == instance.href;
  HTMLAreaElement:
    __base: var instance = document.createElement('area');
    __test: return bcd.testObjectName(instance, 'HTMLAreaElement');
    toString: |-
      instance.href = 'https://mdn-bcd-collector.appspot.com/';
      return instance.toString() == instance.href;
  HTMLAudioElement:
    __base: var instance = document.createElement('audio');
    __test: return bcd.testObjectName(instance, 'HTMLAudioElement');
  HTMLBaseElement:
    __base: var instance = document.createElement('base');
    __test: return bcd.testObjectName(instance, 'HTMLBaseElement');
  HTMLBaseFontElement:
    __base: var instance = document.createElement('basefont');
    __test: return bcd.testObjectName(instance, 'HTMLBaseFontElement');
  HTMLBodyElement:
    __base: var instance = document.createElement('body');
    __test: return bcd.testObjectName(instance, 'HTMLBodyElement');
  HTMLBRElement:
    __base: var instance = document.createElement('br');
    __test: return bcd.testObjectName(instance, 'HTMLBRElement');
  HTMLButtonElement:
    __base: var instance = document.createElement('button');
    __test: return bcd.testObjectName(instance, 'HTMLButtonElement');
  HTMLCanvasElement:
    __base: var instance = document.createElement('canvas');
    __test: return bcd.testObjectName(instance, 'HTMLCanvasElement');
  HTMLCollection:
    __base: var instance = document.forms;
  HTMLContentElement:
    __base: var instance = document.createElement('content');
    __test: return bcd.testObjectName(instance, 'HTMLContentElement');
  HTMLDataElement:
    __base: var instance = document.createElement('data');
    __test: return bcd.testObjectName(instance, 'HTMLDataElement');
  HTMLDataListElement:
    __base: var instance = document.createElement('datalist');
    __test: return bcd.testObjectName(instance, 'HTMLDataListElement');
  HTMLDetailsElement:
    __base: var instance = document.createElement('details');
    __test: return bcd.testObjectName(instance, 'HTMLDetailsElement');
  HTMLDialogElement:
    __base: var instance = document.createElement('dialog');
    __test: return bcd.testObjectName(instance, 'HTMLDialogElement');
  HTMLDirectoryElement:
    __base: var instance = document.createElement('dir');
    __test: return bcd.testObjectName(instance, 'HTMLDirectoryElement');
  HTMLDivElement:
    __base: var instance = document.createElement('div');
    __test: return bcd.testObjectName(instance, 'HTMLDivElement');
  HTMLDListElement:
    __base: var instance = document.createElement('dl');
    __test: return bcd.testObjectName(instance, 'HTMLDListElement');
  HTMLDocument:
    __base: var instance = document;
  HTMLElement:
    __base: var instance = document.createElement('b');
  HTMLEmbedElement:
    __base: var instance = document.createElement('embed');
    __test: return bcd.testObjectName(instance, 'HTMLEmbedElement');
  HTMLFieldSetElement:
    __base: var instance = document.createElement('fieldset');
    __test: return bcd.testObjectName(instance, 'HTMLFieldSetElement');
  HTMLFontElement:
    __base: var instance = document.createElement('font');
    __test: return bcd.testObjectName(instance, 'HTMLFontElement');
  HTMLFormControlsCollection:
    __base: |-
      <%api.HTMLFormElement:form%>
      for (var i = 0; i < 3; i++) {
        var input = document.createElement('input');
        input.value = i;
        form.appendChild(input);
      }
      var instance = form.elements;
  HTMLFormElement:
    __base: var instance = document.createElement('form');
    __test: return bcd.testObjectName(instance, 'HTMLFormElement');
  HTMLFrameElement:
    __base: var instance = document.createElement('frame');
    __test: return bcd.testObjectName(instance, 'HTMLFrameElement');
  HTMLFrameSetElement:
    __base: var instance = document.createElement('frameset');
    __test: return bcd.testObjectName(instance, 'HTMLFrameSetElement');
  HTMLHeadElement:
    __base: var instance = document.createElement('head');
    __test: return bcd.testObjectName(instance, 'HTMLHeadElement');
  HTMLHeadingElement:
    __base: var instance = document.createElement('h1');
    __test: return bcd.testObjectName(instance, 'HTMLHeadingElement');
  HTMLHRElement:
    __base: var instance = document.createElement('hr');
    __test: return bcd.testObjectName(instance, 'HTMLHRElement');
  HTMLHtmlElement:
    __base: var instance = document.createElement('html');
    __test: return bcd.testObjectName(instance, 'HTMLHtmlElement');
  HTMLIFrameElement:
    __base: var instance = document.createElement('iframe');
    __test: return bcd.testObjectName(instance, 'HTMLIFrameElement');
  HTMLImageElement:
    __base: var instance = document.createElement('img');
    __test: return bcd.testObjectName(instance, 'HTMLImageElement');
  HTMLInputElement:
    __base: var instance = document.createElement('input');
    __test: return bcd.testObjectName(instance, 'HTMLInputElement');
  HTMLIsIndexElement:
    __base: var instance = document.createElement('isindex');
    __test: return bcd.testObjectName(instance, 'HTMLIsIndexElement');
  HTMLKeygenElement:
    __base: var instance = document.createElement('keygen');
    __test: return bcd.testObjectName(instance, 'HTMLKeygenElement');
  HTMLLabelElement:
    __base: var instance = document.createElement('label');
    __test: return bcd.testObjectName(instance, 'HTMLLabelElement');
  HTMLLegendElement:
    __base: var instance = document.createElement('legend');
    __test: return bcd.testObjectName(instance, 'HTMLLegendElement');
  HTMLLIElement:
    __base: var instance = document.createElement('li');
    __test: return bcd.testObjectName(instance, 'HTMLLIElement');
  HTMLLinkElement:
    __base: var instance = document.createElement('link');
    __test: return bcd.testObjectName(instance, 'HTMLLinkElement');
  HTMLMapElement:
    __base: var instance = document.createElement('map');
    __test: return bcd.testObjectName(instance, 'HTMLMapElement');
  HTMLMarqueeElement:
    __base: var instance = document.createElement('marquee');
    __test: return bcd.testObjectName(instance, 'HTMLMarqueeElement');
  HTMLMediaElement:
    __base: <%api.HTMLVideoElement:instance%>
    __test: return bcd.testObjectName(instance, 'HTMLVideoElement');
  HTMLMenuElement:
    __base: var instance = document.createElement('menu');
    __test: return bcd.testObjectName(instance, 'HTMLMenuElement');
  HTMLMenuItemElement:
    __base: var instance = document.createElement('menuitem');
    __test: return bcd.testObjectName(instance, 'HTMLMenuItemElement');
  HTMLMetaElement:
    __base: var instance = document.createElement('meta');
    __test: return bcd.testObjectName(instance, 'HTMLMetaElement');
  HTMLMeterElement:
    __base: var instance = document.createElement('meter');
    __test: return bcd.testObjectName(instance, 'HTMLMeterElement');
  HTMLModElement:
    __base: var instance = document.createElement('del');
    __test: return bcd.testObjectName(instance, ['HTMLModElement', 'HTMLDelElement']);
  HTMLObjectElement:
    __base: var instance = document.createElement('object');
    __test: return bcd.testObjectName(instance, 'HTMLObjectElement');
  HTMLOListElement:
    __base: var instance = document.createElement('ol');
    __test: return bcd.testObjectName(instance, 'HTMLOListElement');
  HTMLOptGroupElement:
    __base: var instance = document.createElement('optgroup');
    __test: return bcd.testObjectName(instance, 'HTMLOptGroupElement');
  HTMLOptionElement:
    __base: var instance = document.createElement('option');
    __test: return bcd.testObjectName(instance, 'HTMLOptionElement');
  HTMLOptionsCollection:
    __base: |-
      var el = document.createElement('select');
      for (var i = 0; i < 3; i++) {
        el.appendChild(document.createElement('option'));
      }
      var instance = el.options;
  HTMLOutputElement:
    __base: var instance = document.createElement('output');
    __test: return bcd.testObjectName(instance, 'HTMLOutputElement');
  HTMLParagraphElement:
    __base: var instance = document.createElement('p');
    __test: return bcd.testObjectName(instance, 'HTMLParagraphElement');
  HTMLParamElement:
    __base: var instance = document.createElement('param');
    __test: return bcd.testObjectName(instance, 'HTMLParamElement');
  HTMLPictureElement:
    __base: var instance = document.createElement('picture');
    __test: return bcd.testObjectName(instance, 'HTMLPictureElement');
  HTMLPortalElement:
    __base: var instance = document.createElement('portal');
    __test: return bcd.testObjectName(instance, 'HTMLPortalElement');
  HTMLPreElement:
    __base: var instance = document.createElement('pre');
    __test: return bcd.testObjectName(instance, 'HTMLPreElement');
  HTMLProgressElement:
    __base: var instance = document.createElement('progress');
    __test: return bcd.testObjectName(instance, 'HTMLProgressElement');
  HTMLQuoteElement:
    __base: var instance = document.createElement('blockquote');
    __test: return bcd.testObjectName(instance, ['HTMLQuoteElement', 'HTMLBlockElement', 'HTMLBlockElementConstructor', 'HTMLBlockquoteElement', 'HTMLBlockquoteElementConstructor']);
  HTMLScriptElement:
    __base: var instance = document.createElement('script');
    __test: return bcd.testObjectName(instance, 'HTMLScriptElement');
  HTMLSelectElement:
    __base: var instance = document.createElement('select');
    __test: return bcd.testObjectName(instance, 'HTMLSelectElement');
  HTMLShadowElement:
    __base: var instance = document.createElement('shadow');
    __test: return bcd.testObjectName(instance, 'HTMLShadowElement');
  HTMLSlotElement:
    __base: var instance = document.createElement('slot');
    __test: return bcd.testObjectName(instance, 'HTMLSlotElement');
  HTMLSourceElement:
    __base: var instance = document.createElement('source');
    __test: return bcd.testObjectName(instance, 'HTMLSourceElement');
  HTMLSpanElement:
    __base: var instance = document.createElement('span');
    __test: return bcd.testObjectName(instance, 'HTMLSpanElement');
  HTMLStyleElement:
    __base: var instance = document.createElement('style');
    __test: return bcd.testObjectName(instance, 'HTMLStyleElement');
  HTMLTableCaptionElement:
    __base: var instance = document.createElement('caption');
    __test: return bcd.testObjectName(instance, 'HTMLTableCaptionElement');
  HTMLTableCellElement:
    __base: var instance = document.createElement('td');
    __test: return bcd.testObjectName(instance, ['HTMLTableCellElement', 'HTMLTableDataCellElement']);
  HTMLTableColElement:
    __base: var instance = document.createElement('col');
    __test: return bcd.testObjectName(instance, 'HTMLTableColElement');
  HTMLTableElement:
    __base: var instance = document.createElement('table');
    __test: return bcd.testObjectName(instance, 'HTMLTableElement');
  HTMLTableRowElement:
    __base: var instance = document.createElement('tr');
    __test: return bcd.testObjectName(instance, 'HTMLTableRowElement');
  HTMLTableSectionElement:
    __base: var instance = document.createElement('tbody');
    __test: return bcd.testObjectName(instance, 'HTMLTableSectionElement');
  HTMLTemplateElement:
    __base: var instance = document.createElement('template');
    __test: return bcd.testObjectName(instance, 'HTMLTemplateElement');
  HTMLTextAreaElement:
    __base: var instance = document.createElement('textarea');
    __test: return bcd.testObjectName(instance, 'HTMLTextAreaElement');
  HTMLTimeElement:
    __base: var instance = document.createElement('time');
    __test: return bcd.testObjectName(instance, 'HTMLTimeElement');
  HTMLTitleElement:
    __base: var instance = document.createElement('title');
    __test: return bcd.testObjectName(instance, 'HTMLTitleElement');
  HTMLTrackElement:
    __base: var instance = document.createElement('track');
    __test: return bcd.testObjectName(instance, 'HTMLTrackElement');
  HTMLUListElement:
    __base: var instance = document.createElement('ul');
    __test: return bcd.testObjectName(instance, 'HTMLUListElement');
  HTMLUnknownElement:
    __base: var instance = document.createElement('unknown');
    __test: return bcd.testObjectName(instance, 'HTMLUnknownElement');
  HTMLVideoElement:
    __base: var instance = document.createElement('video');
    __test: return bcd.testObjectName(instance, 'HTMLVideoElement');
  IDBDatabase:
    __base: |-
      <%api.IDBOpenDBRequest:req%>
      req.onsuccess = function() {
        callback(req.result);
      };
      req.onerror = function(event) {
        fail(event.message);
      };
  IDBFactory:
    __base: var instance = self.indexedDB || self.mozIndexedDB || self.webkitIndexedDB || self.msIndexedDB;
  IDBOpenDBRequest:
    __base: |-
      <%api.IDBFactory:idb%>
      var instance = idb.open("collector");
  IDBRequest:
    __base: <%api.IDBOpenDBRequest:instance%>
  IDBVersionChangeEvent:
    __base: |-
      var instance;
      try {
        instance = new IDBVersionChangeEvent('upgradeneeded');
      } catch(e) {
        try {
          instance = document.createEvent('IDBVersionChangeEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  IIRFilterNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createIIRFilter' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createIIRFilter is not defined'};
      }
      var instance = reusableInstances.audioContext.createIIRFilter([1], [1]);
  ImageBitmap:
    __resources:
      - image-black
    __base: |-
      if (!('document' in self)) {
        // XXX Implement worker tests for ImageBitmap
        return {result: null, message: 'Testing ImageBitmap in workers is not yet implemented'};
      }
      var instance = createImageBitmap(document.getElementById('resource-image-black'));
  ImageCapture:
    __base: |-
      <%api.MediaDevices:mediaDevices%>
      if (!('ImageCapture' in self)) {
        return {result: false, message: 'ImageCapture is not defined'};
      }
      var stream = mediaDevices.getUserMedia({video: true});
      stream.then(function() {});
      var promise = stream.then(function(s) {
        var tracks = s.getVideoTracks();
        return new ImageCapture(tracks[0]);
      });
  ImageData:
    __base: |-
      var instance;
      if ('ImageData' in self) {
        instance = new ImageData(5, 5);
      } else if ('document' in self) {
        <%api.CanvasRenderingContext2D:ctx%>
        instance = ctx.createImageData(16, 16);
      }
  InstallEvent:
    __base: |-
      if (!('InstallEvent' in self)) {
        return {result: false, message: 'InstallEvent is not defined'};
      }
      var instance = new InstallEvent('install');
  KeyboardEvent:
    __base: |-
      var instance;
      try {
        instance = new KeyboardEvent('keypress');
      } catch(e) {
        try {
          instance = document.createEvent('KeyboardEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  KHR_parallel_shader_compile:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('KHR_parallel_shader_compile');
  Location:
    __base: var instance = location;
    toString: |-
      if (!('toString' in instance)) {
        return {result: false, message: 'toString is not defined'};
      }
      return instance.toString() == instance.href;
  MediaCapabilities:
    __base: var instance = navigator.mediaCapabilities;
  MediaDeviceInfo:
    __base: |-
      <%api.MediaDevices:mediaDevices%>
      var promise = navigator.mediaDevices.enumerateDevices().then(
        function(devices) {
          return devices[0];
        }
      );
  MediaDevices:
    __base: var instance = navigator.mediaDevices;
  MediaElementAudioSourceNode:
    __resources:
      - audio-blip
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createMediaElementSource' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createMediaElementSource is not defined'};
      }
      var el = document.getElementById('resource-audio-blip');
      // Element is cloned for each test because only one audio source node can be associated with an element
      var clone = el.cloneNode(true);
      var instance = reusableInstances.audioContext.createMediaElementSource(clone);
  MediaEncryptedEvent:
    __base: |-
      if (!('MediaEncryptedEvent' in self)) {
        return {result: false, message: 'MediaEncryptedEvent is not defined'};
      }
      var instance = new MediaEncryptedEvent('encrypted');
  MediaKeyMessageEvent:
    __base: |-
      if (!('MediaKeyMessageEvent' in self)) {
        return {result: false, message: 'MediaKeyMessageEvent is not defined'};
      }
      var instance = new MediaKeyMessageEvent('license-request', {message: new ArrayBuffer(), messageType: 'license-request'});
  MediaList:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@media (max-width: 600px) {body {background-color: #111;color: white;}}');
      var instance = stylesheet.media;
  MediaQuery:
    __base: "var instance = window.matchMedia('screen and max-width: 800px;');"
  MediaQueryListEvent:
    __base: |-
      if (!('MediaQueryListEvent' in self)) {
        return {result: false, message: 'MediaQueryListEvent is not defined'};
      }
      var instance = new MediaQueryListEvent('change');
  MediaSession:
    __base: var instance = navigator.mediaSession;
  MediaSource:
    __base: |-
      if (!('MediaSource' in self)) {
        return {result: false, message: 'MediaSource is not defined'};
      }
      var instance = new MediaSource();
    isTypeSupported: return 'isTypeSupported' in MediaSource;
  MediaStream:
    __base: |-
      <%api.MediaDevices:mediaDevices%>
      var promise = mediaDevices.getUserMedia({audio: true});
      promise.then(function() {});
  MediaStreamAudioDestinationNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createMediaStreamDestination' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createMediaStreamDestination is not defined'};
      }
      var instance = reusableInstances.audioContext.createMediaStreamDestination();
  MediaStreamAudioSourceNode:
    __resources:
      - audioContext
    __base: |-
      <%api.MediaStream:mediaStream%>
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var promise = mediaStream.then(function(ms) {
        return reusableInstances.audioContext.createMediaStreamSource(ms)
      });
  MediaStreamTrack:
    __base: |-
      <%api.MediaStream:mediaStream%>
      var promise = mediaStream.then(function(ms) {
        return ms.getAudioTracks()[0]
      });
  MediaStreamTrackAudioSourceNode:
    __resources:
      - audioContext
    __base: |-
      <%api.MediaStream:mediaStream%>
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createMediaStreamTrackSource' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createMediaStreamTrackSource is not defined'};
      }
      var promise = mediaStream.then(function(ms) {
        var tracks = ms.getTracks();
        return reusableInstances.audioContext.createMediaStreamTrackSource(tracks[0]);
      });
  MerchantValidationEvent:
    __base: |-
      if (!('MerchantValidationEvent' in self)) {
        return {result: false, message: 'MerchantValidationEvent is not defined'};
      }
      var instance = new MerchantValidationEvent('merchantvalidation');
  MessageEvent:
    __base: |-
      var instance;
      try {
        instance = new MessageEvent('message');
      } catch(e) {
        try {
          instance = document.createEvent('MessageEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  MessageChannel:
    __base: |-
      if (!('MessageChannel' in self)) {
        return {result: false, message: 'MessageChannel is not defined'};
      }
      var instance = new MessageChannel();
  MessagePort:
    __base: |-
      <%api.MessageChannel:channel%>
      var instance = channel.port1;
  MimeType:
    __base: var instance = navigator.mimeTypes[0];
  MimeTypeArray:
    __base: var instance = navigator.mimeTypes;
  MouseEvent:
    __base: |-
      var instance;
      try {
        instance = new MouseEvent('click');
      } catch(e) {
        try {
          instance = document.createEvent('MouseEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  MutationEvent:
    __base: |-
      try {
        var instance = document.createEvent('MutationEvent');
      } catch(e) {
        if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
          return {result: false, message: 'Cannot create event'};
        }
        throw e;
      }
  MutationObserver:
    __base: |-
      var constructor = window.MutationObserver || window.WebKitMutationObserver;
      if (!constructor) {
        return {result: false, message: '(WebKit)MutationObserver is not defined'};
      };
      var instance = new constructor(function(mutations){});
  NamedNodeMap:
    __base: var instance = document.body.attributes;
  Navigator:
    __base: var instance = navigator;
  Node:
    __base: var instance = document;
  NodeList:
    __base: var instance = document.childNodes;
  NodeIterator:
    __base: var instance = document.createNodeIterator(document);
  Notification:
    __base: |-
      if (!('Notification' in self)) {
        return {result: false, message: 'Notification is not defined'};
      }
      var instance = new Notification('');
  NotificationEvent:
    __base: |-
      <%api.Notification:notification%>
      if (!('NotificationEvent' in self)) {
        return {result: false, message: 'NotificationEvent is not defined'};
      }
      var instance = new NotificationEvent('notificationclick', {notification});
  OfflineAudioCompletionEvent:
    __resources:
      - audioContext
    __base: |-
      <%api.AudioBuffer:buffer%>
      if (!('OfflineAudioCompletionEvent' in self)) {
        return {result: false, message: 'OfflineAudioCompletionEvent is not defined'};
      }
      var instance = new OfflineAudioCompletionEvent('complete', {renderedBuffer: buffer});
  OfflineAudioContext:
    __resources:
      - offlineAudioContext
    __base: var instance = reusableInstances.offlineAudioContext;
    __test: return 'OfflineAudioContext' in self;
  OscillatorNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createOscillator();
  OES_draw_buffers_indexed:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('OES_draw_buffers_indexed');
  OES_element_index_uint:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_element_index_uint');
  OES_fbo_render_mipmap:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_fbo_render_mipmap');
  OES_standard_derivatives:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_standard_derivatives');
  OES_texture_float:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_texture_float');
  OES_texture_float_linear:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('OES_texture_float_linear');
  OES_texture_half_float:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_texture_half_float');
  OES_texture_half_float_linear:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('OES_texture_half_float_linear');
  OES_vertex_array_object:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_vertex_array_object');
  OVR_multiview2:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      var instance = reusableInstances.webGL2.getExtension('OVR_multiview2');
  PageTransitionEvent:
    __base: |-
      var instance;
      try {
        instance = new PageTransitionEvent('pageshow');
      } catch(e) {
        try {
          instance = document.createEvent('PageTransitionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  PannerNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createPanner();
  Performance:
    __base: |-
      if (!('performance' in self)) {
        return {result: false, message: 'performance is not defined'};
      };
      var instance = performance;
  PerformanceEntry:
    __base: |-
      <%api.Performance:prf%>
      if (!('getEntries' in prf)) {
        return {result: false, message: 'performance.getEntries is not defined'};
      }
      var instance = prf.getEntries()[0];
  PerformanceMark:
    __base: |-
      <%api.Performance:prf%>
      if (!('mark' in prf)) {
        return {result: false, message: 'performance.mark is not defined'};
      };
      performance.mark('mark');
      var instance = performance.getEntriesByName('mark')[0];
  PerformanceNavigation:
    __base: |-
      <%api.Performance:prf%>
      var instance = performance.navigation;
  PerformanceResourceTiming:
    __base: var instance = performance.getEntriesByType("resource")[0];
  PerformanceTiming:
    __base: |-
      <%api.Performance:prf%>
      var instance = performance.timing;
  PeriodicWave:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var real = new Float32Array(2);
      var imag = new Float32Array(2);
      var instance = reusableInstances.audioContext.createPeriodicWave(real, imag);
  Plugin:
    __base: |-
      if (!navigator.plugins.length) {
        throw new Error('navigator.plugins is empty');
      }
      var instance = navigator.plugins[0];
  PluginArray:
    __base: var instance = navigator.plugins;
  PopStateEvent:
    __base: |-
      var instance;
      try {
        instance = new PopStateEvent('popstate');
      } catch(e) {
        try {
          instance = document.createEvent('PopStateEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  ProcessingInstruction:
    __base: |-
      var doc = new DOMParser().parseFromString('<foo />', 'application/xml');
      var instance = doc.createProcessingInstruction('xml-stylesheet', 'href="mycss.css" type="text/css"');
  ProgressEvent:
    __base: |-
      var instance;
      try {
        instance = new ProgressEvent('progress');
      } catch(e) {
        try {
          instance = document.createEvent('ProgressEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  PushEvent:
    __base: |-
      if (!('PushEvent' in self)) {
        return {result: false, message: 'PushEvent is not defined'};
      }
      var instance = new PushEvent('push');
  RadioNodeList:
    __base: |-
      <%api.HTMLFormElement:form%>
      for (var i = 0; i < 3; i++) {
        var input = document.createElement('input');
        input.value = i;
        input.type = "radio";
        input.name = "radio";
        form.appendChild(input);
      }
      var instance = form.elements.namedItem('radio');
  Range:
    __base: var instance = document.createRange();
  Request:
    __base: var instance = new Request('');
  Response:
    __base: var instance = new Response('');
  RTCDataChannel:
    __base: |-
      <%api.RTCPeerConnection:connection%>
      var instance = connection.createDataChannel('channel');
  RTCDataChannelEvent:
    __base: |-
      <%api.RTCDataChannel:channel%>
      if (!('RTCDataChannelEvent' in self)) {
        return {result: false, message: 'RTCDataChannelEvent is not defined'};
      }
      var instance = new RTCDataChannelEvent('datachannel', {channel: channel});
  RTCDTMFToneChangeEvent:
    __base: |-
      if (!('RTCDTMFToneChangeEvent' in self)) {
        return {result: false, message: 'RTCDTMFToneChangeEvent is not defined'};
      }
      var instance = new RTCDTMFToneChangeEvent('tonechange', {tone: ''});
  RTCIceCandidate:
    __base: "var instance = new RTCIceCandidate({candidate: 'candidate:4234997325 1 udp 2043278322 192.168.0.56 44323 typ host', sdpMid: ''});"
  RTCPeerConnection:
    __base: |-
      /* Firefox briefly defines RTCPeerConnection in older versions, but it is not a valid constructor until later versions. */
      var constructor = window.mozRTCPeerConnection || window.RTCPeerConnection || window.webkitRTCPeerConnection;
      if (!constructor) {
        return {result: false, message: '(moz/webkit)RTCPeerConnection is not defined or is falsy'};
      };
      var instance = new constructor({iceServers: []});
  RTCSessionDescription:
    __base: "var instance = new RTCSessionDescription({type: 'offer'});"
  Screen:
    __base: var instance = window.screen;
  ScriptProcessorNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createScriptProcessor();
  SecurityPolicyViolationEvent:
    __base: |-
      if (!('SecurityPolicyViolationEvent' in self)) {
        return {result: false, message: 'SecurityPolicyViolationEvent is not defined'};
      }
      var instance = new SecurityPolicyViolationEvent('securitypolicyviolation');
  Selection:
    __base: var instance = window.getSelection();
  ServiceWorkerContainer:
    __base: var instance = navigator.serviceWorker;
  ShadowRoot:
    __base: |-
      var el = document.createElement('div');
      if (!el.attachShadow) {
        return {result: false, message: 'Element.attachShadow is not defined'};
      };
      el.attachShadow({mode: 'open'});
      var instance = el.shadowRoot;
  SpeechRecognition:
    __resources:
      - speechRecognition
    __base: var instance = reusableInstances.speechRecognition;
    __test: return 'SpeechRecognition' in self;
  SpeechRecognitionErrorEvent:
    __base: |-
      var instance;
      try {
        instance = new SpeechRecognitionErrorEvent('error');
      } catch(e) {
        try {
          instance = document.createEvent('SpeechRecognitionErrorEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  SpeechRecognitionEvent:
    __base: |-
      var instance;
      try {
        instance = new SpeechRecognitionEvent('result');
      } catch(e) {
        try {
          instance = document.createEvent('SpeechRecognitionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  SpeechSynthesis:
    __base: var instance = window.speechSynthesis;
  SpeechSynthesisErrorEvent:
    __base: |-
      var instance;
      try {
        instance = new SpeechSynthesisErrorEvent('error');
      } catch(e) {
        try {
          instance = document.createEvent('SpeechSynthesisErrorEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  SpeechSynthesisEvent:
    __base: |-
      var instance;
      try {
        instance = new SpeechSynthesisEvent('start');
      } catch(e) {
        try {
          instance = document.createEvent('SpeechSynthesisEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  SpeechSynthesisUtterance:
    __base: var instance = new SpeechSynthesisUtterance('Hello world!');
  SpeechSynthesisVoice:
    __base: |-
      <%api.SpeechSynthesis:synth%>
      var instance = synth.getVoices()[0];
  StereoPannerNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createStereoPanner();
  StorageEvent:
    __base: |-
      var instance;
      try {
        instance = new StorageEvent('storage');
      } catch(e) {
        try {
          instance = document.createEvent('StorageEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  StyleMedia:
    __base: var instance = window.styleMedia;
  StyleSheet:
    __resources:
      - createStyleSheet
    __base: <%api.CSSStyleSheet:instance%>
  StyleSheetList:
    __base: var instance = document.styleSheets;
  SubtleCrypto:
    __base: |-
      if (!('crypto' in self)) {
        return {result: false, message: 'crypto is not defined'};
      };
      var instance = crypto.subtle || crypto.webkitSubtle;
  SVGAElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'a');
    __test: return bcd.testObjectName(instance, 'SVGAElement');
  SVGAngle:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGAngle();
  SVGAnimatedAngle:
    __base: |-
      <%api.SVGMarkerElement:el%>
      var instance = el.orientAngle;
  SVGAnimatedBoolean:
    __base: |-
      <%api.SVGFEConvolveMatrixElement:el%>
      var instance = el.preserveAlpha;
  SVGAnimatedEnumeration:
    __base: |-
      <%api.SVGMarkerElement:el%>
      var instance = el.orientType;
  SVGAnimatedInteger:
    __base: |-
      <%api.SVGFEConvolveMatrixElement:el%>
      var instance = el.orderX;
  SVGAnimatedLength:
    __base: |-
      <%api.SVGMarkerElement:el%>
      var instance = el.refX;
  SVGAnimatedLengthList:
    __base: |-
      <%api.SVGTextPositioningElement:el%>
      var instance = el.x;
  SVGAnimatedNumber:
    __base: |-
      <%api.SVGStopElement:el%>
      var instance = el.offset;
  SVGAnimatedNumberList:
    __base: |-
      <%api.SVGFEConvolveMatrixElement:el%>
      var instance = el.kernelMatrix;
  SVGAnimatedPreserveAspectRatio:
    __base: |-
      <%api.SVGFEImageElement:el%>
      var instance = el.preserveAspectRatio;
  SVGAnimatedRect:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.viewBox;
  SVGAnimatedString:
    __base: |-
      <%api.SVGElement:el%>
      var instance = el.className;
  SVGAnimatedTransformList:
    __base: |-
      <%api.SVGGraphicsElement:el%>
      var instance = el.transform;
  SVGAltGlyphDefElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'altGlyphDef');
    __test: return bcd.testObjectName(instance, 'SVGAltGlyphDefElement');
  SVGAltGlyphElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'altGlyph');
    __test: return bcd.testObjectName(instance, 'SVGAltGlyphElement');
  SVGAltGlyphItemElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'altGlyphItem');
    __test: return bcd.testObjectName(instance, 'SVGAltGlyphItemElement');
  SVGAnimateColorElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'animateColor');
    __test: return bcd.testObjectName(instance, 'SVGAnimateColorElement');
  SVGAnimateElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
    __test: return bcd.testObjectName(instance, 'SVGAnimateElement');
  SVGAnimateMotionElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
    __test: return bcd.testObjectName(instance, 'SVGAnimateMotionElement');
  SVGAnimateTransformElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'animateTransform');
    __test: return bcd.testObjectName(instance, 'SVGAnimateTransformElement');
  SVGAnimationElement:
    __base: <%api.SVGAnimateElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGAnimateElement');
  SVGCircleElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    __test: return bcd.testObjectName(instance, 'SVGCircleElement');
  SVGClipPathElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
    __test: return bcd.testObjectName(instance, 'SVGClipPathElement');
  SVGColorProfileElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'color-profile');
    __test: return bcd.testObjectName(instance, 'SVGColorProfileElement');
  SVGComponentTransferFunctionElement:
    __base: <%api.SVGFEFuncAElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGFEFuncAElement');
  SVGCursorElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'cursor');
    __test: return bcd.testObjectName(instance, 'SVGCursorElement');
  SVGDefsElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    __test: return bcd.testObjectName(instance, 'SVGDefsElement');
  SVGDescElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'desc');
    __test: return bcd.testObjectName(instance, 'SVGDescElement');
  SVGDiscardElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'discard');
    __test: return bcd.testObjectName(instance, 'SVGDiscardElement');
  SVGElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'title');
  SVGEllipseElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
    __test: return bcd.testObjectName(instance, 'SVGEllipseElement');
  SVGFEBlendElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feBlend');
    __test: return bcd.testObjectName(instance, 'SVGFEBlendElement');
  SVGFEColorMatrixElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feColorMatrix');
    __test: return bcd.testObjectName(instance, 'SVGFEColorMatrixElement');
  SVGFEComponentTransferElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feComponentTransfer');
    __test: return bcd.testObjectName(instance, 'SVGFEComponentTransferElement');
  SVGFECompositeElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
    __test: return bcd.testObjectName(instance, 'SVGFECompositeElement');
  SVGFEConvolveMatrixElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feConvolveMatrix');
    __test: return bcd.testObjectName(instance, 'SVGFEConvolveMatrixElement');
  SVGFEDiffuseLightingElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feDiffuseLighting');
    __test: return bcd.testObjectName(instance, 'SVGFEDiffuseLightingElement');
  SVGFEDisplacementMapElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feDisplacementMap');
    __test: return bcd.testObjectName(instance, 'SVGFEDisplacementMapElement');
  SVGFEDistantLightElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feDistantLight');
    __test: return bcd.testObjectName(instance, 'SVGFEDistantLightElement');
  SVGFEDropShadowElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feDropShadow');
    __test: return bcd.testObjectName(instance, 'SVGFEDropShadowElement');
  SVGFEFloodElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feFlood');
    __test: return bcd.testObjectName(instance, 'SVGFEFloodElement');
  SVGFEFuncAElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncA');
    __test: return bcd.testObjectName(instance, 'SVGFEFuncAElement');
  SVGFEFuncBElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncB');
    __test: return bcd.testObjectName(instance, 'SVGFEFuncBElement');
  SVGFEFuncGElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncG');
    __test: return bcd.testObjectName(instance, 'SVGFEFuncGElement');
  SVGFEFuncRElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncR');
    __test: return bcd.testObjectName(instance, 'SVGFEFuncRElement');
  SVGFEGaussianBlurElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
    __test: return bcd.testObjectName(instance, 'SVGFEGaussianBlurElement');
  SVGFEImageElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feImage');
    __test: return bcd.testObjectName(instance, 'SVGFEImageElement');
  SVGFEMergeElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
    __test: return bcd.testObjectName(instance, 'SVGFEMergeElement');
  SVGFEMergeNodeElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
    __test: return bcd.testObjectName(instance, 'SVGFEMergeNodeElement');
  SVGFEMorphologyElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feMorphology');
    __test: return bcd.testObjectName(instance, 'SVGFEMorphologyElement');
  SVGFEOffsetElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
    __test: return bcd.testObjectName(instance, 'SVGFEOffsetElement');
  SVGFEPointLightElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'fePointLight');
    __test: return bcd.testObjectName(instance, 'SVGFEPointLightElement');
  SVGFESpecularLightingElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feSpecularLighting');
    __test: return bcd.testObjectName(instance, 'SVGFESpecularLightingElement');
  SVGFESpotLightElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feSpotLight');
    __test: return bcd.testObjectName(instance, 'SVGFESpotLightElement');
  SVGFETileElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feTile');
    __test: return bcd.testObjectName(instance, 'SVGFETileElement');
  SVGFETurbulenceElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feTurbulence');
    __test: return bcd.testObjectName(instance, 'SVGFETurbulenceElement');
  SVGFilterElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
    __test: return bcd.testObjectName(instance, 'SVGFilterElement');
  SVGFontElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font');
    __test: return bcd.testObjectName(instance, 'SVGFontElement');
  SVGFontFaceElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font-face');
    __test: return bcd.testObjectName(instance, 'SVGFontFaceElement');
  SVGFontFaceFormatElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font-face-format');
    __test: return bcd.testObjectName(instance, 'SVGFontFaceFormatElement');
  SVGFontFaceNameElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font-face-name');
    __test: return bcd.testObjectName(instance, 'SVGFontFaceNameElement');
  SVGFontFaceSrcElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font-face-src');
    __test: return bcd.testObjectName(instance, 'SVGFontFaceSrcElement');
  SVGFontFaceUriElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font-face-uri');
    __test: return bcd.testObjectName(instance, 'SVGFontFaceUriElement');
  SVGForeignObjectElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
    __test: return bcd.testObjectName(instance, 'SVGForeignObjectElement');
  SVGGElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    __test: return bcd.testObjectName(instance, 'SVGGElement');
  SVGGeometryElement:
    __base: <%api.SVGPathElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGPathElement');
  SVGGlyphElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'glyph');
    __test: return bcd.testObjectName(instance, 'SVGGlyphElement');
  SVGGlyphRefElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'glyphRef');
    __test: return bcd.testObjectName(instance, 'SVGGlyphRefElement');
  SVGGradientElement:
    __base: <%api.SVGLinearGradientElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGLinearGradientElement');
  SVGGraphicsElement:
    __base: <%api.SVGImageElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGImageElement');
  SVGHKernElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'hkern');
    __test: return bcd.testObjectName(instance, 'SVGHKernElement');
  SVGImageElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'image');
    __test: return bcd.testObjectName(instance, 'SVGImageElement');
  SVGLength:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGLength();
  SVGLengthList:
    __base: |-
      <%api.SVGAnimatedLengthList:list%>
      var instance = list.baseVal;
  SVGLinearGradientElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
    __test: return bcd.testObjectName(instance, 'SVGLinearGradientElement');
  SVGLineElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    __test: return bcd.testObjectName(instance, 'SVGLineElement');
  SVGMarkerElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    __test: return bcd.testObjectName(instance, 'SVGMarkerElement');
  SVGMaskElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
    __test: return bcd.testObjectName(instance, 'SVGMaskElement');
  SVGMeshElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'mesh');
    __test: return bcd.testObjectName(instance, 'SVGMeshElement');
  SVGMetadataElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');
    __test: return bcd.testObjectName(instance, 'SVGMetadataElement');
  SVGMissingGlyphElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'missing-glyph');
    __test: return bcd.testObjectName(instance, 'SVGMissingGlyphElement');
  SVGMPathElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'mpath');
    __test: return bcd.testObjectName(instance, 'SVGMPathElement');
  SVGNumber:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGNumber();
  SVGNumberList:
    __base: |-
      <%api.SVGAnimatedNumberList:list%>
      var instance = list.baseVal;
  SVGPathElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    __test: return bcd.testObjectName(instance, 'SVGPathElement');
  SVGPatternElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
    __test: return bcd.testObjectName(instance, 'SVGPatternElement');
  SVGPoint:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGPoint();
  SVGPointList:
    __base: |-
      <%api.SVGPolygonElement:el%>
      var instance = el.points;
  SVGPolygonElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    __test: return bcd.testObjectName(instance, 'SVGPolygonElement');
  SVGPolylineElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    __test: return bcd.testObjectName(instance, 'SVGPolylineElement');
  SVGPreserveAspectRatio:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.preserveAspectRatio.baseVal;
  SVGRadialGradientElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
    __test: return bcd.testObjectName(instance, 'SVGRadialGradientElement');
  SVGRect:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGRect();
  SVGRectElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    __test: return bcd.testObjectName(instance, 'SVGRectElement');
  SVGScriptElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'script');
    __test: return bcd.testObjectName(instance, 'SVGScriptElement');
  SVGSetElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'set');
    __test: return bcd.testObjectName(instance, 'SVGSetElement');
  SVGSolidcolorElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'solidcolor');
    __test: return bcd.testObjectName(instance, 'SVGSolidcolorElement');
  SVGStopElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    __test: return bcd.testObjectName(instance, 'SVGStopElement');
  SVGStringList:
    __base: |-
      <%api.SVGGraphicsElement:el%>
      var instance = el.systemLanguage;
  SVGStyleElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'style');
    __test: return bcd.testObjectName(instance, 'SVGStyleElement');
  SVGSVGElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    __test: return bcd.testObjectName(instance, 'SVGSVGElement');
  SVGSwitchElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'switch');
    __test: return bcd.testObjectName(instance, 'SVGSwitchElement');
  SVGSymbolElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'symbol');
    __test: return bcd.testObjectName(instance, 'SVGSymbolElement');
  SVGTextElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    __test: return bcd.testObjectName(instance, 'SVGTextElement');
  SVGTextContentElement:
    __base: <%api.SVGTextElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGTextElement');
  SVGTextPathElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');
    __test: return bcd.testObjectName(instance, 'SVGTextPathElement');
  SVGTextPositioningElement:
    __base: <%api.SVGTextElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGTextElement');
  SVGTitleElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'title');
    __test: return bcd.testObjectName(instance, 'SVGTitleElement');
  SVGTransform:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGTransform();
  SVGTransformList:
    __base: |-
      <%api.SVGAnimatedTransformList:list%>
      var instance = list.baseVal;
  SVGTRefElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'tref');
    __test: return bcd.testObjectName(instance, 'SVGTRefElement');
  SVGTSpanElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
    __test: return bcd.testObjectName(instance, 'SVGTSpanElement');
  SVGUnknownElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'unknown');
    __test: return bcd.testObjectName(instance, 'SVGUnknownElement');
  SVGUseElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'use');
    __test: return bcd.testObjectName(instance, 'SVGUseElement');
  SVGViewElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'view');
    __test: return bcd.testObjectName(instance, 'SVGViewElement');
  SVGVKernElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'vkern');
    __test: return bcd.testObjectName(instance, 'SVGVKernElement');
  Text:
    __base: |-
      var el = document.createElement('b');
      el.innerHTML = 'text';
      var instance
      = el.childNodes[0];
  TextDecoder:
    __base: |-
      if (!('TextDecoder' in self)) {
        return {result: false, message: 'TextDecoder is not defined'};
      };
      var instance = new TextDecoder();
  TextEncoder:
    __base: |-
      if (!('TextEncoder' in self)) {
        return {result: false, message: 'TextEncoder is not defined'};
      };
      var instance = new TextEncoder();
  TextMetrics:
    __base: |-
      <%api.CanvasRenderingContext2D:ctx%>
      var instance = ctx.measureText('mdn-bcd-collector');
  TextTrack:
    __resources:
      - video-blank
    __base: |-
      <%api.TextTrackList:texttracks%>
      var instance = texttracks[0];
  TextTrackCue:
    __resources:
      - video-blank
    __base: |-
      <%api.TextTrackCueList:cues%>
      var instance = cues[0];
  TextTrackCueList:
    __resources:
      - video-blank
    __base: |-
      <%api.TextTrack:texttrack%>
      var instance = texttrack.cues;
  TextTrackList:
    __resources:
      - video-blank
    __base: |-
      var el = document.getElementById('resource-video-blank');
      var instance = el.textTracks;
  TimeRanges:
    __resources:
      - video-blank
    __base: |-
      var el = document.getElementById('resource-video-blank');
      var instance = el.buffered;
  TouchEvent:
    __base: |-
      if (!('TouchEvent' in self)) {
        return {result: false, message: 'TouchEvent is not defined'};
      }
      var instance = new TouchEvent('touchstart');
  TrackEvent:
    __base: |-
      var instance;
      try {
        instance = new TrackEvent('addtrack');
      } catch(e) {
        try {
          instance = document.createEvent('TrackEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  TransitionEvent:
    __base: |-
      var instance;
        try {instance = new TransitionEvent('transitionend');
      } catch(e) {
        try {
          instance = document.createEvent('TransitionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  TreeWalker:
    __base: var instance = document.createTreeWalker(document);
  UIEvent:
    __base: |-
      var instance;
      try {
        instance = new UIEvent('');
      } catch(e) {
        try {
          instance = document.createEvent('UIEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  URL:
    __base: |-
      var instance;
      try {
        instance = new URL(location.href)
      } catch(e) {
        instance = new webkitURL(location.href)
      };
    __test: return 'URL' in self;
  ValidityState:
    __base: |-
      <%api.HTMLInputElement:el%>
      var instance = el.validity;
  VideoTrack:
    __resources:
      - video-blank
    __base: |-
      <%api.VideoTrackList:videoTracks%>
      var instance = videoTracks[0];
  VideoTrackList:
    __resources:
      - video-blank
    __base: |-
      var el = document.getElementById('resource-video-blank');
      var instance = el.videoTracks;
  VTTCue:
    __resources:
      - video-blank
    __base: <%api.TextTrackCue:instance%>
  WaveShaperNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createWaveShaper();
  WebGLContextEvent:
    __base: |-
      var instance;
      try {
        instance = new WebGLContextEvent('webglcontextlost');
      } catch(e) {
        if (!('document' in self)) {
          return {result: false, message: 'Cannot create event'};
        }
        try {
          instance = document.createEvent('WebGLContextEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  WebGLRenderingContext:
    __resources:
      - webGL1
    __base: var instance = reusableInstances.webGL1;
  WebGL2RenderingContext:
    __resources:
      - webGL2
    __base: var instance = reusableInstances.webGL2;
  WEBGL_blend_equation_advanced_coherent:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_blend_equation_advanced_coherent');
  WEBGL_color_buffer_float:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('WEBGL_color_buffer_float');
  WEBGL_compressed_texture_astc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_astc');
  WEBGL_compressed_texture_atc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_atc');
  WEBGL_compressed_texture_etc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_etc');
  WEBGL_compressed_texture_etc1:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_etc1');
  WEBGL_compressed_texture_pvrtc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_pvrtc');
  WEBGL_compressed_texture_s3tc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_s3tc');
  WEBGL_compressed_texture_s3tc_srgb:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_s3tc_srgb');
  WEBGL_debug_renderer_info:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_debug_renderer_info');
  WEBGL_debug_shaders:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_debug_shaders');
  WEBGL_depth_texture:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('WEBGL_depth_texture');
  WEBGL_draw_buffers:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('WEBGL_draw_buffers');
  WEBGL_draw_instanced_base_vertex_base_instance:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_draw_instanced_base_vertex_base_instance');
  WEBGL_multi_draw:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_multi_draw');
  WEBGL_multi_draw_instanced_base_vertex_base_instance:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_multi_draw_instanced_base_vertex_base_instance');
  WEBGL_lose_context:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_lose_context');
  WebGLTimerQueryEXT:
    __resources:
      - webGL
    __base: |-
      <%api.EXT_disjoint_timer_query:ext%>
      var instance = ext.createQueryEXT();
  WebGLVertexArrayObjectOES:
    __resources:
      - webGL1
    __base: |-
      <%api.OES_vertex_array_object:ext%>
      var instance = ext.createVertexArrayOES();
  WebKitAnimationEvent:
    __base: |-
      var instance;
      try {
        instance = new WebKitAnimationEvent('webkitAnimationEnd');
      } catch(e) {
        try {
          instance = document.createEvent('WebKitAnimationEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  WebKitTransitionEvent:
    __base: |-
      var instance;
      try {
        instance = new WebKitTransitionEvent('webkitTransitionEnd');
      } catch(e) {
        try {
          instance = document.createEvent('WebKitTransitionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  WebSocket:
    __base: |-
      var constructor = self.WebSocket || self.MozWebSocket;
      if (!constructor) {
        return {result: false, message: '(Moz)WebSocket is not defined or falsy'};
      }
      var instance = new constructor('wss://' + location.hostname);
  WheelEvent:
    __base: |-
      var instance;
      try {
        instance = new WheelEvent('wheel');
      } catch(e) {
        try {
          instance = document.createEvent('WheelEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  Window:
    __base: var instance = window;
  WorkerGlobalScope:
    __base: var instance = self;
  WorkerLocation:
    __base: var instance = location;
    toString: |-
      if (!('toString' in instance)) {
        return {result: false, message: 'toString is not defined'};
      }
      return instance.toString() == instance.href;
  WorkerNavigator:
    __base: var instance = navigator;
  Worklet:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.audioWorklet;
  WritableStreamDefaultController:
    __base: |-
      if (!('WritableStream' in self)) {
        return {result: false, message: 'WritableStream is not defined'};
      };
      var promise = new Promise(function(resolve, reject) {
        new WritableStream({
          start(controller) {
            resolve(controller)
          }
        })
      });
  WritableStreamDefaultWriter:
    __base: |-
      if (!('WritableStream' in self)) {
        return {result: false, message: 'WritableStream is not defined'};
      };
      var instance = new WritableStream({}).getWriter();
  XMLHttpRequest:
    __base: |-
      if (!('XMLHttpRequest' in self)) {
        return {result: false, message: 'XMLHttpRequest is not defined'};
      }
      var instance = new XMLHttpRequest();
  XMLHttpRequestEventTarget:
    __base: <%api.XMLHttpRequest:instance%>
  XMLHttpRequestUpload:
    __base: |-
      <%api.XMLHttpRequest:xhr%>
      var instance = xhr.upload;
  XPathExpression:
    __base: |-
      var xpe = new XPathEvaluator();
      var instance = xpe.createExpression('//div', xpe.createNSResolver(document));
  XPathResult:
    __base: |-
      <%api.XPathExpression:exp%>
      var instance = exp.evaluate(document, 0, null);

# Custom tests here also need to be in @webref/css or custom-css.json, see
# https://github.com/foolip/mdn-bcd-collector/issues/1944.
css:
  properties:
    custom-property: |-
      return CSS.supports('color', 'var(--foo)') || CSS.supports('color',
      'env(--foo)');
